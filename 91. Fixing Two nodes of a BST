/*
class Node
{
    public:
    int data;
    Node *left, *right;
    Node(int val)
    {
        data = val;
        left = right = NULL;
    }
};
*/

class Solution {
  public:
  
    int getHeight(Node* root , int h ){
        if(root == nullptr)
        return h - 1;
        return max(getHeight(root->left, h + 1), getHeight(root->right , h + 1));
    }
    
    void levelOrder(Node* root){
        if(!root){
            cout<< "N\n";
            return;
        }
        queue<pair<Node*, int>> q;
        q.push({root, 0});
        int lastLevel = 0;
        int height = getHeight(root, 0);
        
        while(!q.empty()){
            auto top = q.front();
            q.pop();
            Node* node = top.first;
            int lvl = top.second;
            
            if(lvl > lastLevel){
                cout<< "\n";
                lastLevel = lvl;
                
            }
            
            if(lvl > height)
            break;
            
            if(node->data != -1)
            cout<<node->data<<" ";
            else
            cout<<"N ";
            
            if(node->data == -1)
            continue;
            
            if(node->left == nullptr)
            q.push({new Node(-1), lvl + 1});
            else
            q.push({node->left, lvl + 1});
            
            if(node->right == nullptr)
            q.push({new Node(-1), lvl + 1});
            else
            q.push({node->right, lvl + 1});
        }
    }
    
    void correctBSTUtil(Node* root, Node*& first, Node*& middle, Node*& last, Node*& prev){
        if(root == nullptr)
        return;
        
        correctBSTUtil(root->left, first, middle , last, prev);
        
        if(prev && root-> data < prev->data){
            if(!first){
                first = prev;
                middle = root;
            }
            else{
                last = root;
            }
        }
        
        prev = root;
        
        correctBSTUtil(root->right , first , middle , last , prev);
    }
    
    void correctBST(Node* root) {
        // add code here
        
        Node *first = nullptr ,  *middle = nullptr , *last = nullptr , *prev = nullptr;
        
        correctBSTUtil(root, first, middle , last , prev);
        
        if(first && last)
        swap(first->data, last->data);
        else
        swap(first->data, middle->data);
    }
};
