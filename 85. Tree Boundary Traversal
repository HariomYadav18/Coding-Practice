/*
class Node {
  public:
    int data;
    Node* left;
    Node* right;

    // Constructor to initialize a new node
    Node(int val) {
        data = val;
        left = NULL;
        right = NULL;
    }
};
*/

class Solution {
  public:
  
   bool isLeaf(Node *node){
       return node->left == nullptr && node->right == nullptr;
   }
   
   void collectLeft(Node *root, vector<int> &res){
       if(root == nullptr)
       return ;
       
       Node *curr = root;
       while(!isLeaf(curr)){
           res.push_back(curr->data);
           
           if(curr->left)
           curr = curr->left;
           
           else
           curr = curr->right;
       }
   }
   
   void collectLeaves(Node* root, vector<int>& res){
       Node* current = root;
       
       while(current){
           if(current->left == nullptr){
               if(current->right == nullptr)
               
               res.push_back(current->data);
               
            current = current->right;
                   
               
           }
           else{
               Node* predecessor = current->left;
               while(predecessor->right && predecessor->right != current){
                   predecessor = predecessor->right;
               }
               
               if(predecessor->right == nullptr){
                   predecessor->right = current;
                   current = current->left;
               }
               else{
                   if(predecessor->left == nullptr)
                   res.push_back(predecessor->data);
                   
                   predecessor->right = nullptr;
                   current = current->right;
               }
           }
       }
       
   }
   
   void collectRight(Node *root, vector<int> &res){
       if(root == nullptr)
       return;
       
       Node *curr = root;
       vector<int> temp;
       while(!isLeaf(curr)){
           temp.push_back(curr->data);
           if(curr->right)
           curr = curr->right;
           else
           curr = curr->left;
           
           
       }
       
       for(int i = temp.size() - 1 ; i>= 0 ; --i)
       res.push_back(temp[i]);
   }
  
    
  
    vector<int> boundaryTraversal(Node *root) {
        // code here
        vector<int> res;
        
        if(!root)
        return res;
        
        if(!isLeaf(root))
        res.push_back(root->data);
        
        collectLeft(root->left,res);
        
        collectLeaves(root,res);
        
        collectRight(root->right, res);
        
        return res;
        
    }
};
