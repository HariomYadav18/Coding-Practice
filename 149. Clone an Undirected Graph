class Solution {
    unordered_map<Node*, Node*> copies;
  public:
    Node* cloneGraph(Node* node) {
        // code here
    
        if(!node) return NULL;
        
        if(copies.find(node) == copies.end()){
            Node* clone = new Node(node->val);
            copies[node] = clone;
            
            for(Node* neighbor : node->neighbors){
                clone->neighbors.push_back(cloneGraph(neighbor));
            }
        }
        
        return copies[node];
        
    }
    
    Node* buildGraph(){
        Node* node1 = new Node(); node1->val = 0;
        Node* node2 = new Node(); node1->val = 1;
        Node* node3 = new Node(); node1->val = 2;
        Node* node4 = new Node(); node1->val = 3;
        
        
        node1->neighbors = {node2,node3};
        node2->neighbors = {node1, node3};
        node3->neighbors = {node1, node2 , node4};
        node4->neighbors = {node3};
        
        return node1;
    }
    
    bool compareGraphs(Node* node1, Node* node2, map<Node*, Node*>& visited){
        if(!node1 || !node2)
        return node1 == node2;
        
        if(node1->val != node2->val || node1 == node2)
        return false;
        
        visited[node1] = node2;
        
        if(node1->neighbors.size() != node2->neighbors.size())
        return false;
        
        for(size_t i = 0; i < node1->neighbors.size();i++){
            Node* n1 = node1->neighbors[i];
            Node* n2  = node2->neighbors[i];
            
            if(visited.count(n1)){
                if(visited[n1] != n2)
                return false;
            }else{
                if(!compareGraphs(n1, n2, visited))
                return false;
            }
            
        }
        return true;
    }
};
